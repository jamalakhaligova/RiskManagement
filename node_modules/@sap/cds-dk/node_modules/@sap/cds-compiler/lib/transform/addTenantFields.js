// Add tenant field MANDT to entities

// Prerequisites:

// - the input CSN is a `client` style CSN from the Core Compiler
// - using structure types with unmanaged associations is not supported by the
//   Core Compiler (due to missing ON-rewrite)

// TODO entities without MANDT:

// - cache whether structure type contains (managed) association to entity with MANDT
// - disallow use of such a type in entity without MANDT

// Implementation remark:

// - the functions `forEachDefinition` & friends in csnUtils.js have become quite
//   (too) general and are probably slow → not used here

'use strict';

const { createMessageFunctions } = require( '../base/messages' );
const { traverseQuery } = require( '../model/csnRefs' );

const fieldName = 'tenant';
const fieldDef = {
  key: true,
  type: 'cds.String',
  length: 36,
  '@cds.api.ignore': true, // and/or $generated: 'tenant' for the full Universal CSN?
};

function addTenantFields( csn, options ) {
  const { definitions } = csn;
  if (!definitions)
    return csn;
  const { error, throwWithError } = createMessageFunctions( options, 'tenant', csn );

  const csnPath = [ 'definitions', '' ];
  let projection;

  for (const name in definitions) {
    const art = definitions[name];
    if (art?.kind !== 'entity')
      continue;
    csnPath[1] = name;

    if (art['@cds.tenant.independent'] != null) {
      error( null, csnPath, { anno: '@cds.tenant.independent' },
             'Can\'t yet add annotation $(ANNO) to an entity' );
    }
    if (!handleElements( art ))
      continue;
    projection = art.query || art.projection && art;
    if (projection)
      traverseQuery( projection, null, null, handleQuery );
  }

  (csn.extensions || []).forEach( (ext, idx) => {
    const tenant = ext.elements?.[fieldName];
    const name = ext.annotate || ext.extend; // extend should not happen
    if (tenant && definitions[name]?.kind === 'entity') { // TODO: ok for tenant-independent
      error( null, [ 'extensions', idx, 'elements', 'tenant' ],
             { name: fieldName },
             'Can\'t annotate element $(NAME) of a tenant-dependent entity' );
    }
  } );

  throwWithError();
  return csn;                   // input CSN changed by side effect

  function handleElements( art ) {
    const { elements } = art;
    if (elements[fieldName]) {
      error( null, [ ...csnPath, 'elements', fieldName ], { name: fieldName },
             'Can\'t add tenant field to entity having an element $(NAME)' );
      return false;
    }
    if (!Object.values( elements ).some( e => e.key )) {
      error( null, csnPath, {},
             'There must be a key in a tenant-dependent entity' );
      return false;
    }
    handleAssociations( art );
    art.elements = { [fieldName]: { ...fieldDef }, ...elements };
    return true;
  }

  function handleQuery( query ) {
    // TODO: errors are temporary: start with simple projections only = no better
    // message $location necessary yet
    if (!projection)            // error already reported
      return;
    if (query.ref) {
      if ((query.as || implicitAs( query.ref )) === fieldName) {
        error( null, csnPath, { name: fieldName },
               'Can\'t have a table alias named $(NAME) in a tenant-dependent entity' );
      }
      return;
    }

    const select = query.SELECT || query.projection;
    if (query.SET || query !== projection || !select?.from?.ref) {
      error( null, csnPath, {},
             'Can\'t add tenant columns to non-simple query entities' );
      projection = null;
      return;
    }

    if (query.projection)
      csnPath.push( 'projection' );
    else
      csnPath.push( 'query', 'SELECT' );

    if (select.mixin)
      handleMixins( select.mixin );
    if (select.excluding)
      checkExcluding( select.excluding );
    if (select.columns)
      handleColumns( select.columns );
    // TODO: for subqueries, we might need to adapt the inferred elements
    // TODO: where exists ref -
    // TODO: select and query clauses, especially with aggregation functions
    handleGroupBy( select );
    csnPath.length = 2;
  }

  function handleMixins( mixin ) {
    csnPath.push( 'mixin', '' );
    for (const name in mixin) {
      csnPath[csnPath.length - 1] = name;
      if (name !== fieldName) {
        addToCondition( mixin[name], name );
      }
      else {
        error( null, csnPath, { name },
               'Can\'t define a mixin named $(NAME) in a tenant-dependent entity' );
      }
    }
    csnPath.length -= 2;
  }

  function checkExcluding( excludeList ) {
    if (excludeList.includes( fieldName )) {
      error( null, csnPath, { name: fieldName },
             'Can\'t exclude $(NAME) from query source' );
    }
  }

  function handleGroupBy( select ) {
    // TODO: in the future, we allow model-wise keyless views when using
    // aggregation function, and add a GROUP BY for MANDT in this case.  Now, also
    // views with agg functions need to have a key element → it very likely
    // already contains a GROUP BY. And anyway: if we miss to add GROUP BY MANDT,
    // the database will complain → no safetly risk.
    if (select.groupBy)
      select.groupBy.unshift( { ref: [ fieldName ] } );
  }

  function handleColumns( columns ) {
    let specifiedKey = false;
    csnPath.push( 'columns', -1 );
    for (const col of columns) {
      ++csnPath[csnPath.length - 1];
      if (col.expand || col.inline) {
        error( null, csnPath, {},
               'Can\'t use expand/inline in a tenant-dependent entity' );
      }
      if (col.key != null)      // yes, also with key: false
        specifiedKey = true;
      if (col.cast?.on) // REDIRECTED TO with explicit ON - TODO (low prio): less $self
        addToCondition( col.cast, col.as || implicitAs( col.ref ) );
    }
    csnPath.length -= 2;
    columns.unshift( specifiedKey
      ? { key: true, ref: [ fieldName ] }
      : { ref: [ fieldName ] } );
  }

  function handleAssociations( elem ) {
    const { elements } = elem;
    if (elements) {
      csnPath.push( 'elements', '' );
      for (const name in elements) {
        csnPath[csnPath.length - 1] = name;
        handleAssociations( elements[name] );
      }
      csnPath.length -= 2;
    }
    else if (elem.target) {
      if (elem.on) {
        addToCondition( elem, csnPath[csnPath.length - 1] );
      }
      else {
        error( null, csnPath, {},
               'Can\'t yet use managed associations in a tenant-dependent entity' );
      }
    }
    else if (elem.items) {
      csnPath.push( 'items' );
      handleAssociations( elem.items );
      --csnPath.length;
    }
  }

  function addToCondition( elem, assoc ) {
    if (!elem.on)
      return;
    const withSelf = csnPath.length > 4;
    elem.on = [
      { ref: [ assoc, fieldName ] }, // TODO: consider assoc name starting with '$'
      '=',
      { ref: (withSelf) ? [ '$self', fieldName ] : [ fieldName ] },
      'and',
      // TODO: avoid (...) for standard AND-ed EQ-comparisons ?
      { xpr: elem.on },
    ];
  }
}

function implicitAs( ref ) {
  const item = ref[ref.length - 1];
  const id = (typeof item === 'string') ? item : item.id;
  return id.substring( id.lastIndexOf('.') + 1 );
}

module.exports = {
  addTenantFields,
};
