const cds = require('../../')
const { odataError } = require('./utils')
const { INSERT } = require('../../lib/ql/cds-ql')
const { readAfterWrite } = require('../_runtime/cds-services/adapter/odata-v4/utils/readAfterWrite')
const metaInfo = require('../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')
const { toODataResult } = require('./result')

module.exports = srv =>
  function create(req, res, next) {
    const query = cds.odata.parse(req.url, { service: srv, baseUrl: req.baseUrl })

    const {
      SELECT: { one }
    } = query

    if (one) {
      const singleton = query.target._isSingleton
      const error = odataError('405', `Method ${req.method} not allowed for ${singleton ? 'SINGLETON' : 'ENTITY'}`)
      return res.status(405).json(error)
    }

    const queryPathXpr = query.SELECT?.from

    const insertQuery = INSERT.into(queryPathXpr).entries(req.body)

    const cdsReq = new cds.Request({ query: insertQuery })
    return srv
      .dispatch(cdsReq)
      .then(async result => {
        if (cdsReq._.readAfterWrite) {
          // TODO see if in old odata impl for other checks that should happen
          result = await readAfterWrite(cdsReq, srv, { operation: { result } })
        }

        if (result == null) {
          res.status(204)
        }

        const info = metaInfo(insertQuery, 'CREATE', srv, req.body, req, false)

        return res.status(201).send(toODataResult(result, info))
      })
      .catch(next)
  }
