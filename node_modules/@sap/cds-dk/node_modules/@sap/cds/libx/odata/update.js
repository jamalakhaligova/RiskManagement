const cds = require('../../')
const metaInfo = require('../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')
const { readAfterWrite } = require('../_runtime/cds-services/adapter/odata-v4/utils/readAfterWrite')
const { where2obj } = require('../_runtime/common/utils/cqn')
const { toODataResult } = require('./result')
const { odataError } = require('./utils')

const _isUpsertAllowed = ({ target, data, event }) => {
  return (
    !(cds.env.runtime && cds.env.runtime.allow_upsert === false) &&
    !(target && target._isDraftEnabled && (!cds.env.fiori.lean_draft || (!data.IsActiveEntity && event === 'PATCH')))
  )
}

const _isNavigationWithKeyInParent = (keys, data, pathExpression, model) => {
  // keys not in data
  if (keys && Object.keys(keys).some(key => key in data)) {
    return false
  }

  const nav = pathExpression.ref && pathExpression.ref.length !== 0 && pathExpression.ref[1]
  const parent = pathExpression.ref && pathExpression.ref[0].id

  // not a navigation
  if (!parent || !nav) {
    return false
  }

  const navID = typeof nav === 'string' ? nav : nav.id
  const navElement = model.definitions[parent].elements[navID]

  // not a containment
  if (!navElement._isContained) {
    return false
  }

  const where = pathExpression.ref[0].where
  return parent && navElement && where
}

module.exports = srv =>
  function update(req, res, next) {
    const query = cds.odata.parse(req.url, { service: srv, baseUrl: req.baseUrl })

    const {
      SELECT: { one }
    } = query

    if (!one) {
      return res.status(405).json(odataError('405', `Method ${req.method} not allowed for ENTITY.COLLECTION`))
    }

    const queryPathXpr = query.SELECT && query.SELECT.from

    const isPrimitive = query._propertyAccess
    const data = isPrimitive ? { [query._propertyAccess]: req.body.value } : req.body

    const updateQuery = UPDATE.entity(queryPathXpr).with(data)

    // we need the cds request, so we can access req._.readAfterWrite
    const cdsReq = new cds.Request({ query: updateQuery })

    const info = metaInfo(query, 'UPDATE', srv, data, req, false)

    if (!isPrimitive && queryPathXpr.ref?.[queryPathXpr.ref.length - 1].where) {
      Object.assign(data, where2obj(queryPathXpr.ref?.[queryPathXpr.ref.length - 1].where))
    }

    return srv
      .dispatch(cdsReq)
      .then(async result => {
        if (!isPrimitive && cdsReq._.readAfterWrite) {
          // TODO see if in old odata impl for other checks that should happen
          result = await readAfterWrite(cdsReq, srv, { operation: { result } })
        }

        if (result == null) {
          res.status(204)
        }

        return res.send(toODataResult(result, info))
      })
      .catch(async e => {
        // UPSERT
        const is404 = e.code === 404 || e.status === 404 || e.statusCode === 404
        if (is404 && !isPrimitive && _isUpsertAllowed({ target: query.target, data: req.body, event: req.method })) {
          // PUT / PATCH with if-match header means "only if already exists", i.e., no insert if not
          if (req.headers['if-match']) throw Object.assign(new Error('412'), { statusCode: 412 })

          if (_isNavigationWithKeyInParent(query.target.keys, data, queryPathXpr, srv.model)) {
            // REVISIT better error message
            return res.status(422).json(odataError('422', `Unprocessable Entity`))
          }

          // REVISIT: up_XX needs to be looked up -> composition of aspect
          const insertQuery = INSERT.into(queryPathXpr).entries(data)
          const cdsReq = new cds.Request({ query: insertQuery })
          let result = await srv.dispatch(cdsReq)

          if (cdsReq._.readAfterWrite) {
            // TODO see if in old odata impl for other checks that should happen
            result = await readAfterWrite(cdsReq, srv, { operation: { result } })
          }

          return res.status(201).send(toODataResult(result, info))
        }
        throw e
      })
      .catch(next)
  }
